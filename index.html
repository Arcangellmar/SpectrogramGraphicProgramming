<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Spectrogram</title>
    <style>
        *{
            margin: 0;
            padding: 0;
            overflow: hidden;
        }
    </style>
</head>
<body>
    <main>
        <div id="Spectrogram">

        </div>
    </main>

    <script src="three.js"></script>

    <script type="x-shader/x-vertex" id="vertexshader">
        attribute float displacement;
        uniform vec3 vLut[1];
        varying vec3 vColor;
        void main(){
            vColor = vLut[0];
            vec3 newPosition = position + normal*displacement/25.5;
            gl_Position = projectionMatrix * modelViewMatrix * vec4(newPosition,1.0);
        }
    </script>

    <script type="x-shader/x-fragment" id="fragmentshader">
        varying vec3 vColor;
        void main(){
            gl_FragColor = vec4(vColor,1.0);
        }
    </script>

    <script>
        "use strict";
        let frequency_samples = 512; //y resolution
        let time_samples = 1200; //x resolution (el tama√±o del lienzo)
        let DATA = new Uint8Array(frequency_samples);
        let camera, scene, renderer;
        let heights, mesh;
        let n_vertices = (frequency_samples + 1) * (time_samples + 1);
        let xsegments = time_samples;
        let ysegments = frequency_samples;

        let xsize = 35;
        let ysize = 20;
        let xhalfSize = xsize / 2;
        let yhalfSize = ysize / 2;
        let xsegmentSize = xsize / xsegments;
        let ysegmentSize = ysize / ysegments;

        init();

        function init(){
            camera = new THREE.PerspectiveCamera(27, window.innerWidth / window.innerHeight, 1, 1000);
	        camera.position.z = 64;
            scene = new THREE.Scene();

            let geometry = new THREE.BufferGeometry();
            let indices = [];
            heights = [];
            let vertices = []


            for(let i = 0; i <= xsegments; i++){
                let x = (i * xsegmentSize) - xhalfSize;
                for(let j = 0; j <= ysegments; j++){
                    let y = (j * ysegmentSize) - yhalfSize;
                    vertices.push(x,y,0);
                    heights.push(Math.random()*255.);
                }
            }

            geometry.setAttribute( 'position', new THREE.Float32BufferAttribute(vertices, 3));
            geometry.setAttribute( 'displacement', new THREE.Uint8BufferAttribute(heights,1));


            for(let i = 0; i < xsegments; i++){
                for(let j = 0; j < ysegments; j++){
                    let a = i * (ysegments + 1) + (j + 1);
                    let b = i * (ysegments + 1) + j;
                    let c = (i + 1) * (ysegments + 1) + j;
                    let d = (i + 1) * (ysegments + 1) + (j+1);
                    //genera dos caras de triangulo por iteracion
                    indices.push(a, b, d);//cara 1
                    indices.push(b, c, d);//cara 2
                }
            }

            geometry.setIndex(indices);

            let string = [[0.5,0,0]]; // [R, G, B]
            var lut = [];
            for (let n=0;n<1;n++) {
                lut.push(new THREE.Vector3((string[n][0]*255-49)/206., (string[n][1]*255-19)/236., (string[n][2]*255-50)/190.));
            }

            var vShader = document.getElementById('vertexshader');
            var fShader = document.getElementById('fragmentshader');

            var uniforms = {
                vLut: {type: "v3v", value: lut}
            }


            //renderizar y conectar con el DIV
            renderer = new THREE.WebGLRenderer ({antialias: true});
            renderer.setPixelRatio(window.devicePixelRatio);
            renderer.setSize(window.innerWidth, window.innerHeight);
            let container = document.getElementById('Spectrogram');
            container.appendChild(renderer.domElement);

            let material = new THREE.ShaderMaterial( {
                uniforms: uniforms,
                vertexShader:   vShader.text,
                fragmentShader: fShader.text
            } );
            mesh = new THREE.Mesh(geometry, material);

            scene.add(mesh);

            mesh.geometry.computeFaceNormals();
            mesh.geometry.computeVertexNormals();

            //render la escena
            renderer.render(scene, camera);
        }
    </script>
</body>
</html>