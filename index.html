<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Spectrogram</title>
    <style>
        *{
            margin: 0;
            padding: 0;
            overflow: hidden;
        }
    </style>
</head>
<body>
    <main>
        <div id="Spectrogram">

        </div>
    </main>

    <script src="three.js"></script>

    <script>
        "use strict";
        let frequency_samples = 512; //y resolution
        let time_samples = 1200; //x resolution (el tama√±o del lienzo)
        let DATA = new Uint8Array(frequency_samples);
        let camera, scene, renderer;
        let heights, mesh;
        let n_vertices = (frequency_samples + 1) * (time_samples + 1);
        let xsegments = time_samples;
        let ysegments = frequency_samples;

        let xsize = 35;
        let ysize = 20;
        let xhalfSize = xsize / 2;
        let yhalfSize = ysize / 2;
        let xsegmentSize = xsize / xsegments;
        let ysegmentSize = ysize / ysegments;

        init();

        function init(){
            camera = new THREE.PerspectiveCamera(27, window.innerWidth / window.innerHeight, 1, 1000);
	        camera.position.z = 64;
            scene = new THREE.Scene();

            let geometry = new THREE.BufferGeometry();
            let indices = [];
            heights = [];
            let vertices = []


            for(let i = 0; i <= xsegments; i++){
                let x = (i * xsegmentSize) - xhalfSize;
                for(let j = 0; j <= ysegments; j++){
                    let y = (j * ysegmentSize) - yhalfSize;
                    vertices.push(x,y,0);
                    heights.push(0);
                }
            }

            geometry.setAttribute( 'position', new THREE.Float32BufferAttribute(vertices, 3));

            for(let i = 0; i < xsegments; i++){
                for(let j = 0; j < ysegments; j++){
                    let a = i * (ysegments + 1) + (j + 1);
                    let b = i * (ysegments + 1) + j;
                    let c = (i + 1) * (ysegments + 1) + j;
                    let d = (i + 1) * (ysegments + 1) + (j+1);
                    //genera dos caras de triangulo por iteracion
                    indices.push(a, b, d);//cara 1
                    indices.push(b, c, d);//cara 2
                }
            }

            geometry.setIndex(indices);

            //renderizar y conectar con el DIV
            renderer = new THREE.WebGLRenderer ({antialias: true});
            renderer.setPixelRatio(window.devicePixelRatio);
            renderer.setSize(window.innerWidth, window.innerHeight);
            let container = document.getElementById('Spectrogram');
            container.appendChild(renderer.domElement);

            let material = new THREE.MeshBasicMaterial({color: "#433F81"});
            mesh = new THREE.Mesh(geometry, material);

            scene.add(mesh);

            //render la escena
            renderer.render(scene, camera);
        }
    </script>
</body>
</html>